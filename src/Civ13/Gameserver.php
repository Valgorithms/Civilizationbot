<?php


/*
 * This file is a part of the Civ13 project.
 *
 * Copyright (c) 2024-present Valithor Obsidion <valithor@valzargaming.com>
 */

namespace Civ13;

use Civ13\Exceptions\FileNotFoundException;
use Civ13\Exceptions\InvalidConfigException;
use Civ13\Exceptions\MissingSystemPermissionException;
use Civ13\Exceptions\PartException;
use Civ13\Exceptions\UserInputException;
use Civ13\Exceptions\VerifierException;
use Discord\Discord;
use Discord\Builders\Components\ActionRow;
use Discord\Builders\Components\Button;
use Discord\Builders\MessageBuilder;
use Discord\Helpers\Collection;
use Discord\Parts\Channel\Channel;
use Discord\Parts\Channel\Message;
use Discord\Parts\Embed\Embed;
use Discord\Parts\Guild\Role;
use Discord\Parts\Interactions\Interaction;
use Discord\Parts\Thread\Thread;
use Discord\Parts\User\Member;
use Monolog\Logger;
use React\EventLoop\StreamSelectLoop;
use React\EventLoop\TimerInterface;
use React\Promise\PromiseInterface;

use function React\Promise\reject;
use function React\Promise\resolve;

class GameServer
{
    /**
     * An array of admin permissions.
     * Each permission is represented by a key-value pair, where the key is the role name in Discord
     * and the value is an array containing the role name in-game and the permission level.
     *
     * @var array
     */
    public const ADMIN_PERMISSIONS = [
        'Owner'                     => ['Host',                     '65535'],
        'Chief Technical Officer'   => ['Chief Technical Officer',  '65535'],
        'Host'                      => ['Host',                     '65535'], // Default Host permission, only used if a higher listed role is not found first
        'Head Admin'                => ['Head Admin',               '16382'], // Deprecation TBD
        //'Manager'                 => ['Manager',                  '16382'], // Deprecated
        //'Supervisor'              => ['Supervisor',               '16382'], // Deprecated
        'Ambassador'                => ['Ambassador',               '16382'], // Default High Staff permission, only used if a higher listed role is not found first
        'Admin'                     => ['Admin',                    '16254'],
        //'Moderator'               => ['Moderator',                '25088'], // Deprecated
        //'Developer'               => ['Developer',                 '7288'], // This Discord role doesn't exist
        //'Mentor'                  => ['Mentor',                   '16384'], // Deprecated
    ];
    public Discord $discord;
    public Logger $logger;
    public StreamSelectLoop $loop;
    public bool $ready = false;

    // Resolved paths
    private readonly string $serverdata;
    private readonly string $discord2unban;
    private readonly string $discord2ban;
    private readonly string $admins;
    private readonly string $whitelist;
    private readonly string $factionlist;
    private readonly string $ranking_path;

    // Required settings
    public readonly string $basedir; // The base directory on the local filesystem.
    public readonly string $key;     // The shorthand alias for the server.
    public readonly string $name;    // The name.
    public readonly string $ip;      // The IP.
    public readonly string $port;    // The port.
    public readonly string $host;    // The host (e.g. Taislin).

    public bool $supported;      // Whether the server is supported by the remote webserver and will appear in data retrieved from it.
    public bool $enabled;        // Whether the server is enabled and accessible by this bot.
    public bool $legacy;         // Whether the server uses Civ13 legacy file cache or newer SQL methods.
    public bool $moderate;       // Whether the server should moderate chat using the bot.
    public bool $panic_bunker;   // Whether the server should only allow verified users to join.
    public bool $log_attacks;    // Whether the server should log attacks to the attack channel.
    public bool $legacy_relay; // The method used to relay chat messages to the server (either 'file' or 'webhook').

    // Discord Channel IDs
    public string $discussion;
    public string $playercount;
    public string $ooc;
    public string $lobby;
    public string $asay;
    public string $ic;
    public string $transit;
    public string $adminlog;
    public string $debug;
    public string $garbage;
    public string $runtime;
    public string $attack;

    // Resolved Discord Role IDs
    public Role $role;
    
    // Generated by the bot
    /**
     * @var Timerinterface[]
     */
    public array $timers = [];
    public array $serverinfo = [];
    public array $players = [];
    public array $seen_players = [];
    public string $current_round = '';
    public ?string $current_round_message_id = null;
    /** @var array<array> */
    public array $rounds = [];

    public string $bancheck_cache = '';

    public function __construct(public Civ13 &$civ13, array &$options)
    {
        $this->discord =& $civ13->discord;
        $this->logger =& $civ13->logger;
        $this->loop = $civ13->loop;
        $this->resolveOptions($options);
        $this->basedir = $options['basedir'];
        $this->key = $options['key'];
        $this->name = $options['name'];
        $this->ip = $options['ip'];
        $this->port = $options['port'];
        $this->host = $options['host'];
        $this->supported = $options['supported'] ?? false;
        $this->enabled = $options['enabled'] ?? false;
        $this->legacy = $options['legacy'] ?? true;
        $this->moderate = $options['moderate'] ?? true;
        $this->panic_bunker = $options['panic_bunker']  ?? false;
        $this->log_attacks = $options['log_attacks'] ?? true;
        $this->legacy_relay = $options['legacy_relay'] ?? false;
        $this->discussion = $options['discussion'];
        $this->playercount = $options['playercount'];
        $this->ooc = $options['ooc'];
        $this->lobby = $options['lobby'];
        $this->asay = $options['asay'];
        $this->ic = $options['ic'];
        $this->transit = $options['transit'];
        $this->adminlog = $options['adminlog'];
        $this->debug = $options['debug'];
        $this->garbage = $options['garbage'];
        $this->runtime = $options['runtime'];
        $this->attack = $options['attack'];
        if ($this->enabled) { // Don't load variables from files if the server is disabled
            if (! $this->rounds = $this->civ13->VarLoad("{$this->key}_rounds.json") ?? []) {
                $this->rounds = [];
                $this->civ13->VarSave("{$this->key}_rounds.json", $this->rounds);
            }
            if (! $current_round = $this->civ13->VarLoad("{$this->key}_current_round.json") ?? []) {
                $current_round = [];
                $this->civ13->VarSave("{$this->key}_current_round.json", $current_round);
            }
            if ($current_round = array_shift($current_round)) {
                $this->rounds[$this->current_round = $current_round]['interrupted'] = true;
                $this->civ13->VarSave("{$this->key}_rounds.json", $this->rounds);
            } else $this->logger->warning("No current round found for {$this->key}.");
        }
        $this->afterConstruct();
    }
    private function afterConstruct(): void
    {
        $this->serverdata = $this->basedir . Civ13::serverdata;
        $this->discord2unban = $this->basedir . Civ13::discord2unban;
        $this->discord2ban = $this->basedir . Civ13::discord2ban;
        $this->admins = $this->basedir . Civ13::admins;
        $this->whitelist = $this->basedir . Civ13::whitelist;
        $this->factionlist = $this->basedir . Civ13::factionlist;
        $this->ranking_path = $this->basedir . Civ13::ranking_path;
        $this->setup();

        if (! $this->enabled) return; // Don't start timers for disabled servers
        $fn = function () {
            $this->logger->info("Getting player count for Gameserver {$this->name}");
            $this->__updateDiscordVariables();
            $this->localServerPlayerCount(); // Populates $this->players
            $this->playercountTimer(); // Update playercount channel every 10 minutes
            $this->serverinfoTimer(); // Hard check playercount and ckeys to scrutinizeCkey() every 3 minutes
            $this->relayTimer(); // File chat relay
            $this->currentRoundEmbedTimer(); // The bot has to see a round id first
        };
        $this->civ13->ready
            ? $fn()
            : $this->discord->once('init', fn() => $fn());
    }
    /**
     * This method is responsible for setting up the game server by performing the following tasks:
     * - Checking if the number of game servers exceeds the limit of 5 and logging a warning if it does.
     * - Adding the game server to the list of game servers in the Civ13 object.
     * - Adding the game server to the list of enabled game servers in the Civ13 object if it is enabled.
     * - Logging an informational message about the added game server.
     * - Setting the "ready" flag to true.
     *
     * @return void
     */
    private function setup()
    {
        if ($this->ready) return;
        if (count($this->civ13->gameservers) > 5) $this->logger->warning('Configuring more than 5 gameservers are not supported and you will likely experience issues.');
        $this->civ13->gameservers[$this->key] =& $this;
        if ($this->enabled) $this->civ13->enabled_gameservers[$this->key] =& $this;
        $this->logger->info('Added ' . ($this->enabled ? 'enabled' : 'disabled') . " game server: {$this->name} ({$this->key})");
        $this->ready = true;
    }
    private function __updateDiscordVariables()
    {
        if ($guild = $this->civ13->discord->guilds->get('id', $this->civ13->civ13_guild_id)) {
            if (! $this->role = $guild->roles->get('name', $this->name)) {
                $this->logger->error("Role not found for Gameserver {$this->key}.");
                return;
            }
        }
    }
    private function resolveOptions(array $options)
    {
        $requiredProperties = [
            'basedir',
            'key',
            'name',
            'ip',
            'port',
            'host'
        ];
        foreach ($requiredProperties as $property)
            if (! isset($options[$property]))
                throw new \RuntimeException("Gameserver missing required property: $property");
        $optionalProperties = [
            'discussion',
            'playercount',
            'ooc',
            'lobby',
            'asay',
            'ic',
            'transit',
            'adminlog',
            'debug',
            'garbage',
            'runtime',
            'attack'
        ];
        foreach ($optionalProperties as $property)
            if (! isset($options[$property]))
                trigger_error("Gameserver missing optional property: $property", E_USER_WARNING);
    }
    
    /**
     * Returns an array of the player count for each locally hosted server in the configuration file.
     *
     * @return int The total player count for this locally hosted server, or 0 if the server is not local.
     */
    public function localServerPlayerCount(array $players = []): int
    {    
        if (! $this->enabled) return 0;
        if ($this->ip !== $this->civ13->httpServiceManager->httpHandler->external_ip) return 0; // Don't try and access files if the server is not local
        $socket = @fsockopen('localhost', intval($this->port), $errno, $errstr, 1);
        if (! is_resource($socket)) return 0;
        fclose($socket);
        $playercount = 0;
        if (! @file_exists($this->serverdata) || ! $data = @file_get_contents($this->serverdata)) {
            $this->logger->warning("Unable to open `{$this->serverdata}`");
            return 0;
        }
        $data = self::explodeServerdata($data);
        if (isset($data[11])) $players = array_filter(array_map(fn($player) => Civ13::sanitizeInput($player), array_filter(explode('&', $data[11]), fn($player) => $player)));
        if (isset($data[4])) $playercount = $data[4]; // Player count
        $this->players = $players;
        return $playercount;
    }
    
    /**
     * Relays game chat messages to specified paths.
     *
     * This method takes an array of paths and relays game chat messages to those paths.
     * If no paths are provided, it defaults to relaying to the #ooc-server and #asay-server paths.
     *
     * @param array $paths An associative array where keys are file paths and values are the corresponding chat channels IDs.
     * @return bool Returns true if all chat messages were successfully relayed, false otherwise.
     */
    private function __gameChatFileRelay(array $paths): bool
    {
        $result = true;
        foreach ($paths as $filepath => $channel)
            $this->gameChatFileRelay($this->basedir . $filepath, $channel)
                ?: (($result = false) && $this->logger->error("Failed to relay chat messages to $filepath"));
        return $result;
    }
    /**
     * Relays in-game chat messages to Discord and handles chat moderation.
     *
     * This function reads chat messages from a file and relays them to a Discord channel.
     * It also performs chat moderation by checking for blacklisted words and applying warnings and bans to players.
     *
     * @param string $file_path The path to the file containing the chat messages.
     * @param string $channel_id The ID of the Discord channel to relay the messages to.
     * @param bool|null $moderate (Optional) Whether to enable chat moderation. Defaults to false.
     * @param bool $ooc (Optional) Whether to include out-of-character (OOC) messages. Defaults to true.
     * @return bool Returns true if the chat messages were successfully relayed, false otherwise.
     */
    public function gameChatFileRelay(string $file_path, string $channel_id, ?bool $ooc = true, ?bool $moderate = null): bool
    {
        if (! $this->legacy_relay) return false;
        if (! $return = $this->gameChatFileRelay($file_path, $channel_id, $ooc, $moderate ?? $this->moderate)) $this->legacy_relay = false; // Failsafe to prevent the bot from calling this function again. This should be a safe alternative to disabling relaying entirely.
        return $return;
    }
    /**
     * Relays game chat messages to a Discord channel using a webhook.
     *
     * @param string $ckey The ckey of the player sending the message.
     * @param string $message The message to be relayed.
     * @param string $channel_id The ID of the Discord channel to relay the message to.
     * @param bool|null $moderate Whether to moderate the message or not. Defaults to true.
     * @param bool|null $ooc Whether the message is out-of-character or not. Defaults to true.
     * @return PromiseInterface<Message> A promise that resolves with the message sent to the channel.
     */
    public function gameChatWebhookRelay(string $message, string $channel_id, ?string $ckey = null, ?bool $ooc = true, ?bool $moderate = true): PromiseInterface
    {
        if ($this->legacy_relay) return reject(new \LogicException('gameChatWebhookRelay() is not available for legacy relays.'));
        if (! $message || ! is_string($channel_id) || ! is_numeric($channel_id)) {
            $this->logger->warning($err = 'gameChatWebhookRelay() was called with invalid parameters: ' . json_encode(['ckey' => $ckey, 'message' => $message, 'channel_id' => $channel_id]));
            return reject(new \InvalidArgumentException($err));
        }
        if (! $channel = $this->discord->getChannel($channel_id)) {
            $this->logger->warning($err = "gameChatWebhookRelay() was unable to retrieve the channel with ID `$channel_id`");
            return reject(new PartException($err));
        }
        
        if (! $this->ready || ! $this->civ13->ready) {
            $this->civ13->deferUntilReady(fn() => $this->gameChatWebhookRelay($message, $channel_id, $ckey, $ooc, $moderate), 'gameChatWebhookRelay');
            return resolve(null);
        }
        
        ($ckey)
            ? $this->__gameChatRelay($channel, ['ckey' => $ckey, 'message' => $message, 'server' => explode('-', $channel->name)[1]], $ooc, $moderate)    
            : $this->civ13->sendMessage($channel_id, $message); // Send the message as is if no ckey is provided
        return resolve(null);
    }
    /**
     * Relays game chat messages to a Discord channel.
     *
     * @param Channel|Thread|string $channel The Discord channel to send the message to.
     * @param array $array The array containing the chat message information.
     * @param bool $moderate (optional) Whether to apply moderation to the message. Default is true.
     * @param bool $ooc (optional) Whether the message is out-of-character (OOC) or in-character (IC). Default is true.
     * @return PromiseInterface<Message> A promise that resolves with the message sent to the channel.
     */
    private function __gameChatRelay(Channel|Thread|string $channel, array $array, ?bool $ooc = true, ?bool $moderate = true): PromiseInterface
    {
        if (is_string($channel) && ! $channel = $this->discord->getChannel($channel)) {
            $this->logger->error($err = "Channel not found for __gameChatRelay");
            return reject(new PartException($err));
        }
        if (! $array || ! isset($array['ckey']) || ! isset($array['message']) || ! isset($array['server']) || ! $array['ckey'] || ! $array['message'] || ! $array['server']) {
            $this->logger->warning($err = '__gameChatRelay() was called with an empty array or invalid content.');
            return reject(new \InvalidArgumentException($err));
        }
        if (isset($this->civ13->moderator) && $this->moderate && $moderate) {
            $badwords = $ooc ? $this->civ13->ooc_badwords : $this->civ13->ic_badwords;
            $badword_warnings = $ooc ? $this->civ13->ooc_badwords_warnings : $this->civ13->ic_badwords_warnings;
            $this->civ13->moderator->moderate(
                $this,
                $array['ckey'],
                $array['message'],
                $badwords,
                $badword_warnings
            );
        }
        if (! $item = $this->civ13->verifier->get('ss13', Civ13::sanitizeInput($array['ckey']))) {
            return $this->civ13->sendMessage($channel, $array['message'], 'relay.txt', false, false);
        }
        $embed = $this->civ13->createEmbed(false)->setDescription($array['message']);
        if ($user = $this->discord->users->get('id', $item['discord'])) $embed->setAuthor("{$user->username} ({$user->id})", $user->avatar);
        // else $this->discord->users->fetch('id', $item['discord']); // disabled to prevent rate limiting
        return $channel->sendMessage(MessageBuilder::new()->addEmbed($embed));
    }
    public function relayTimer(): ?TimerInterface
    {
        if (! $this->discord->guilds->get('id', $this->civ13->civ13_guild_id)) return null;
        if (! (isset($this->timers['relay_timer'])) || (! $this->timers['relay_timer'] instanceof TimerInterface)) {
            $this->logger->debug("Starting file chat relay timer for {$this->key}");
            if (! isset($this->timers['relay_timer'])) $this->timers['relay_timer'] = $this->discord->getLoop()->addPeriodicTimer(10, fn () => $this->__gameChatFileRelay([Civ13::ooc_path => $this->ooc, Civ13::asay_path => $this->asay]));
        }
        return $this->timers['relay_timer'];
    }
    public function serverinfoTimer(): TimerInterface
    {
        if (! isset($this->timers['serverinfo_timer'])) $this->timers['serverinfo_timer'] = $this->discord->getLoop()->addPeriodicTimer(180, function () {
            if (! /*$playercount =*/ $this->localServerPlayerCount()) return; // No data available
            foreach ($this->players as $ckey) {
                if (is_null($ckey)) continue;
                if (isset($this->civ13->moderator)) $this->civ13->moderator->scrutinizeCkey($ckey);
            }
        });
        return $this->timers['serverinfo_timer']; // Check players every minute
    }
    public function serverinfoPlayers(): array
    { 
        if (empty($data_json = $this->serverinfo)) return [];
        $this->players = [];
        foreach ($data_json as $server) {
            if (array_key_exists('ERROR', $server)) continue;
            //$stationname = $server['stationname'] ?? ''; // TODO: Compare this to the server's name as it appears on the Byond hub
            foreach (array_keys($server) as $key) if (($p = explode('player', $key)) && isset($p[1]) && is_numeric($p[1])) {
                $this->players[] = $ckey = Civ13::sanitizeInput(urldecode($server[$key]));
                if (! array_key_exists($ckey, $this->rounds[$this->current_round]['players'])) { // TODO
                    $this->rounds[$this->current_round]['players'][$ckey] = [];
                }
            }
        }
        return $this->players;
    }
    /**
     * Creates and returns a periodic timer for updating the current round embed message.
     * If the timer does not already exist, it initializes the timer and sets it to update
     * the current round embed message every 60 seconds.
     *
     * @return TimerInterface The periodic timer for updating the current round embed message.
     */
    public function currentRoundEmbedTimer(): TimerInterface
    {
        if (! isset($this->timers['current_round_embed'])) {
            $this->updateCurrentRoundEmbedMessageBuilder();
            $this->timers['current_round_embed'] = $this->loop->addPeriodicTimer(60, fn() => $this->updateCurrentRoundEmbedMessageBuilder());
        }
        return $this->timers['current_round_embed'];
    }
    /**
     * Updates the current round embed message builder.
     *
     * @param MessageBuilder|null $builder The message builder to used to perform the update the message. Defaults to null.
     * @return PromiseInterface<Message> A promise that resolves when the update is complete.
     */
    public function updateCurrentRoundEmbedMessageBuilder(?MessageBuilder $builder = null): PromiseInterface
    {
        if (! $guild = $this->discord->guilds->get('id', $this->civ13->civ13_guild_id)) {
            $this->logger->error($err = "Could not find Guild with ID `{$this->civ13->civ13_guild_id}`");
            return reject(new PartException($err));
        }
        if (! $channel = $guild->channels->get('id', $this->playercount)) {
            $this->logger->error($err = "Could not find Channel with ID `{$this->playercount}`");
            return reject(new PartException($err));
        }
        if (! $builder = $this->createCurrentRoundEmbedMessageBuilder()) {
            $this->logger->error($err = "Could not create a MessageBuilder for {$this->key}");
            return reject(new PartException($err));
        }

        $fulfilledEdit   = fn(?Message $message = null) => $message ? $message->edit($builder)->then($this->civ13->onFulfilledDefault, $this->civ13->onRejectedDefault) : null;
        $fulfilledSend   = fn(Message $message) => $this->civ13->VarSave("{$this->key}_current_round_message_id.json", [$this->current_round_message_id = $message->id]);
        $fulfilledReject = fn(\Throwable $error): PromiseInterface => $channel->sendMessage($builder)->then($fulfilledSend, $this->civ13->onRejectedDefault);
        
        if ($this->current_round_message_id) return $channel->messages->fetch($this->current_round_message_id)->then($fulfilledEdit, $fulfilledReject);
        if (! $this->current_round_message_id) // Attempt to load the current round message ID from the file cache
            if ($serialized_array = $this->civ13->VarLoad("{$this->key}_current_round_message_id.json"))
                if ($this->current_round_message_id = array_shift($serialized_array))
                    return $channel->messages->fetch($this->current_round_message_id)->then($fulfilledEdit, $fulfilledReject);
        return $channel->sendMessage($builder)->then($fulfilledSend, $this->civ13->onRejectedDefault);
    }
    /**
     * Creates the current round embed message builder.
     *
     * @return MessageBuilder|null The created message builder, or null if the round data is not available.
     */
    public function createCurrentRoundEmbedMessageBuilder(): ?MessageBuilder
    {
        if (! $round = $this->getRound($this->current_round)) return null;
        $round_embed_builder = function () use ($round): MessageBuilder
        {
            if (file_exists($this->serverdata) && $data = @file_get_contents($this->serverdata)) $data = self::explodeServerdata($data);
            $embed = $this->civ13->createEmbed()
                    ->setTitle($this->name)
                    //->addFieldValues('Game ID', $game_id);
                    ->addFieldValues('Start', $round['start'] ?? 'Unknown', true)
                    ->addFieldValues('End', $round['end'] ?? 'Ongoing/Unknown', true);
            if (isset($data[7])) $embed->addFieldValues('Round Time', $this->parseRoundTime($data[7]), true);
            if (isset($data[8])) $embed->addFieldValues('Map', $data[8], true);
            if (isset($data[9])) $embed->addFieldValues('Epoch', $data[9], true);
            if (isset($data[10])) $embed->addFieldValues('Season', $data[10], true);
            if ($this->players) $embed->addFieldValues('Online Players (' . count($this->players) . ')', empty($this->players) ? 'N/A' : implode(', ', $this->players), true);
            if (($players = implode(', ', array_keys($round['players']))) && strlen($players) <= 1024) $embed->addFieldValues('Participating Players (' . count($round['players']) . ')', $players);
            else $embed->addFieldValues('Participating Players (' . count($round['players']) . ')', 'Either none or too many to list!');
            if ($discord_ids = array_filter(array_map(fn($c) => ($item = $this->civ13->verifier->get('ss13', $c)) ? "<@{$item['discord']}>" : null, array_keys($round['players'])))) {
                if (strlen($verified_players = implode(', ', $discord_ids)) <= 1024) $embed->addFieldValues('Verified Players (' . count($discord_ids) . ')', $verified_players);
                else $embed->addFieldValues('Verified Players (' . count($discord_ids) . ')', 'Too many to list!');
            }
            return MessageBuilder::new()->setContent("Round data for game_id `$this->current_round`")->addEmbed($embed);
        };
        $builder = $round_embed_builder();

        $interaction_log_handler = function (Interaction $interaction, string $command): PromiseInterface
        {
            if (! $interaction->member->roles->has($this->civ13->role_ids['Admin'])) return $interaction->sendFollowUpMessage(MessageBuilder::new()->setContent('You do not have permission to use this command.'), true);
            $tokens = explode(';', substr($command, strlen('logs ')));
            if (! isset($this->basedir) || ! file_exists($this->basedir . Civ13::log_basedir)) return $this->logger->warning($error = "Either basedir or `" . Civ13::log_basedir . "` is not defined or does not exist");

            unset($tokens[0]);
            $results = $this->civ13->FileNav($this->basedir . Civ13::log_basedir, $tokens);
            if (! $results[0]) return $interaction->sendFollowUpMessage(MessageBuilder::new()->setContent('No logs found.'), true);
            return $interaction->sendFollowUpMessage(MessageBuilder::new()->addFile($results[1], 'log.txt'), true);
        };
        if ($log = str_replace('/', ';', "logs {$this->key}{$round['log']}")) $builder->addComponent(
            ActionRow::new()->addComponent(
                Button::new(Button::STYLE_PRIMARY, $log)
                    ->setLabel('Log')
                    ->setEmoji('ðŸ“')
                    ->setListener(fn($interaction) => $interaction->acknowledge()->then(fn() => $interaction_log_handler($interaction, $interaction->data['custom_id'])), $this->discord, $oneOff = false)
            )
        );
        return $builder;
    }

    public function playercountTimer(): TimerInterface
    {
        // Update playercount channel every 10 minutes
        if (! isset($this->timers['playercount_timer]'])) $this->timers['playercount_timer'] = $this->loop->addPeriodicTimer(600, fn () => $this->playercountChannelUpdate(count($this->players)));
        return $this->timers['playercount_timer'];
    }

    /*
     * This function parses the serverinfo data and updates the relevant Discord channel name with the current player counts
     * Prefix is used to differentiate between two different servers, however it cannot be used with more due to ratelimits on Discord
     * It is called on ready and every 5 minutes
     * 
     * @param int $count The player count to update the channel with.
     * @return PromiseInterface<?Channel> A promise that resolves to the updated channel, or null if the channel didn't need to be updated.
     */
    public function playercountChannelUpdate(int $count = 0): PromiseInterface
    {
        if (! $channel = $this->discord->getChannel($this->playercount)) {
            $this->logger->warning($err = "Channel {$this->playercount} doesn't exist!");
            return reject(new PartException($err));
        }
        if (! $channel->created) {
            $this->logger->warning($err = "Channel {$channel->name} hasn't been created!");
            return reject(new PartException($err));
        }
        [$channelPrefix, $existingCount] = explode('-', $channel->name);
        if ((int)$existingCount !== $count) {
            $channel->name = "{$channelPrefix}-{$count}";
            return $channel->guild->channels->save($channel);
        }
        return resolve(null);
    }

    /**
     * Sends an out-of-character (OOC) message.
     *
     * @param string $message The message to be sent.
     * @param string $sender The sender of the message.
     * @return bool Returns a PromiseInterface if the message is successfully sent, or false if sending the message fails.
     */
    public function OOCMessage(string $message, string $sender): bool
    {
        if (! $this->enabled) return false;
        if (! touch($path = $this->basedir . Civ13::discord2ooc) || ! $file = @fopen($path, 'a')) {
            $this->logger->error("Unable to open `$path` for writing");
            return false;
        }
        fwrite($file, "$sender:::$message" . PHP_EOL);
        fclose($file);
        //if (($this->legacy_relay) && $this->ooc && $channel = $this->discord->getChannel($this->ooc)) if ($promise = $this->relayPlayerMessage($channel, $message, $sender)) return $promise;
        return true;
    }
    /**
     * Sends an admin message to the server.
     *
     * @param string $message The message to send.
     * @param string $sender The sender of the message.
     * @return bool Returns true if the message was sent successfully, false otherwise.
     */
    public function AdminMessage(string $message, string $sender): PromiseInterface|bool
    {
        if (! $this->enabled) return false;
        if (! @touch($path = $this->basedir . Civ13::discord2admin) || ! $file = @fopen($path, 'a')) {
            $this->logger->error("Unable to open `$path` for writing");
            return false;
        }
        fwrite($file, "$sender:::$message" . PHP_EOL);
        fclose($file);
        //if (($this->legacy_relay) && $this->asay && $channel = $this->discord->getChannel($this->asay)) if ($promise = $this->relayPlayerMessage($channel, $message, $sender, null, $urgent)) return $promise;
        return true;
    }
    /**
     * Sends a direct message to a recipient using the specified sender and message.
     *
     * @param string $recipient The recipient of the direct message.
     * @param string $message The content of the direct message.
     * @param string $sender The sender of the direct message.
     * @return bool Returns true if the direct message was sent successfully, false otherwise.
     */
    public function DirectMessage(string $message, string $sender, string $recipient): bool
    {
        if (! $this->enabled) return false;
        if (! @touch($path = $this->basedir . Civ13::discord2dm) || ! $file = @fopen($path, 'a')) {
            $this->logger->debug("Unable to open `$path` for writing");
            return false;
        }
        fwrite($file, "$sender:::$recipient:::$message" . PHP_EOL);
        fclose($file);
        //if (($this->legacy_relay) && $this->asay && $channel = $this->discord->getChannel($this->asay)) if ($promise = $this->relayPlayerMessage($channel, $message, $sender, $recipient)) return $promise;
        return true;
    }
    /**
     * Sends a player message to a channel.
     *
     * @param Channel|Thread|string $channel The channel to send the message to.
     * @param bool $urgent Whether the message is urgent or not.
     * @param string $content The content of the message.
     * @param string $sender The sender of the message (ckey or Discord username).
     * @param string $recipient The recipient of the message (optional).
     * @param string $file_name The name of the file to attach to the message (default: 'message.txt').
     * @param bool $prevent_mentions Whether to prevent mentions in the message (default: false).
     * @return PromiseInterface<Message>|null A promise that resolves to the sent message, or null if the message couldn't be sent.
     */
    /*public function relayPlayerMessage(Channel|Thread|string $channel, string $content, string $sender, ?string $recipient = '', ?bool $urgent = false, string $file_name = 'message.txt', bool $prevent_mentions = false): PromiseInterface|false
    {
        if (is_string($channel) && ! $channel = $this->discord->getChannel($channel)) {
            $this->logger->error("Channel not found for relayPlayerMessage");
            return false;
        }
        $then = function (Message $message) { $this->logger->debug("Urgent message sent to {$message->channel->name} ({$message->channel->id}): {$message->content} with message link {$message->url}"); };

        // Sender is the ckey or Discord username
        $ckey = null;
        $user = null;
        $verified = false;
        if (isset($this->civ13->verifier) && $item = $this->civ13->verifier->getVerifiedItem($sender)) {
            $ckey = $item['ss13'];
            $verified = true;
            $user = $this->civ13->verifier->getVerifiedUser($ckey);
        }
        $content = '**__['.date('H:i:s', time()).']__ ' . ($ckey ?? $sender) . ": **$content";

        $builder = MessageBuilder::new();
        if ($urgent) $builder->setContent("<@&{$this->civ13->role_ids['Admin']}>, an urgent message has been sent!");
        if (! $urgent && $prevent_mentions) $builder->setAllowedMentions(['parse'=>[]]);
        if (! $verified && strlen($content)<=2000) return $channel->sendMessage($builder->setContent($content))->then($then, null);
        if (strlen($content)>4096) return $channel->sendMessage($builder->addFileFromContent($file_name, $content))->then($then, null);
        $embed = $this->civ13->createEmbed(false)->setDescription($content);
        if ($recipient) $embed->setTitle(($ckey ?? $sender) . " => $recipient");
        if ($user) $embed->setAuthor("{$user->username} ({$user->id})", $user->avatar);
        return $channel->sendMessage($builder->addEmbed($embed))->then($then, null);
    }*/

    public function Host(?Message $message = null): void
    {
        OSFunctions::execInBackground("python3 {$this->basedir}" . Civ13::updateserverabspaths);
        if (file_exists($this->basedir . Civ13::serverdata)) OSFunctions::execInBackground("rm -f {$this->basedir}" . Civ13::serverdata);
        OSFunctions::execInBackground("python3 $this->basedir}" . Civ13::killsudos);

        if (! isset($this->civ13->timers["{$this->key}host"])) {
            $this->civ13->timers["{$this->key}host"] = $this->civ13->discord->getLoop()->addTimer(30, function () use ($message) {
                OSFunctions::execInBackground("nohup DreamDaemon {$this->basedir}" . Civ13::dmb . " {$this->port} -trusted -webclient -logself &");
                unset($this->civ13->timers["{$this->key}host"]);
                if ($message) $message->react("ðŸ‘");
            });
        } else $this->logger->info("Server host timer already exists for {$this->key}.");
    }
    public function Kill(?Message $message = null, bool $notify = true): void
    {
        if ($notify) {
            $sender = ($message && $message->user_id) ? $this->civ13->verifier->getVerifiedItem($message->user_id)['ss13'] : ($this->civ13->discord->id ?? $this->civ13->discord->username);
            $this->OOCMessage("Server is shutting down. To get notified when we go live again, please join us on Discord at {$this->civ13->discord_formatted}", $sender);
        }
        $this->civ13->loop->addTimer(10, function () use ($message): void
        {
            OSFunctions::execInBackground("python3 {$this->basedir}" . Civ13::killciv13);
            if ($message) $message->react("ðŸ‘");
        });
    }
    public function Restart(?Message $message = null, bool $notify = true): void
    {
        $this->Kill(null, false);
        $this->civ13->loop->addTimer(20, function () use ($message, &$gameserver): void
        {
            $this->Host($message);
        });
        if ($notify) $this->OOCMessage("Server is now restarting. To share your feedback or experiences for this round, please join us on Discord at {$this->civ13->discord_formatted}", $message ? ($this->civ13->verifier->getVerifiedItem($message->author)['ss13'] ?? $this->civ13->discord->username) : $this->civ13->discord->username);
    }
    /**
     * Swaps the current map to the specified map.
     *
     * @param string $mapto The name of the map to switch to.
     * @param string $admin The name of the admin requesting the map swap.
     * @return PromiseInterface<string> A promise that resolves with a success message or rejects with an error message.
     */
    public function MapSwap(string $mapto, string $admin): PromiseInterface
    {
        $mapto = strtoupper($mapto);
        if (! file_exists($fp = $this->civ13->gitdir . Civ13::maps) || ! $file = @fopen($fp, 'r')) {
            $this->logger->error($err = "Unable to open `$fp` for reading.");
            return reject(new FileNotFoundException($err));
        }
    
        $maps = array();
        while (($fp = fgets($file, 4096)) !== false) {
            $linesplit = explode(' ', trim(str_replace('"', '', $fp)));
            if (isset($linesplit[2]) && $map = trim($linesplit[2])) $maps[] = $map;
        }
        fclose($file);
        if (! in_array($mapto, $maps)) return reject(new UserInputException("`$mapto` was not found in the map definitions."));

        $this->OOCMessage($msg = "Server is now changing map to `$mapto`.", $this->civ13->verifier->getVerifiedItem($admin)['ss13'] ?? $this->civ13->discord->username);
        if ($channel = $this->civ13->discord->getChannel($this->discussion)) {
            if (isset($this->civ13->role_ids['mapswap']) && $role = $this->civ13->role_ids['mapswap']); $msg = "<@&$role>, {$this->name} $msg";
            $channel->sendMessage($msg);
        }
        $this->loop->addTimer(10, fn() => OSFunctions::execInBackground("python3 {$this->basedir}" . Civ13::mapswap . " $mapto"));
        return resolve($msg);
    }

    public function cleanupLogs(): void
    {
        $this->__cleanupLog($this->basedir . Civ13::bans);
        $this->__cleanupLog($this->basedir . Civ13::playerlogs);
    }
    public function __cleanupLog(string $path): bool
    {
        if (! @file_exists($path)) {
            $this->logger->warning("Unable to open `$path`");
            return false;
        }
        if (($original_file_contents = @file_get_contents($path)) === false) {
            $this->logger->warning("Unable to read `$path`");
            return false;
        }
        $original_file_contents = str_replace('||||||', '|||', $original_file_contents);
        $new_file_contents = explode(PHP_EOL, $original_file_contents);
        $new_file_contents = array_unique($new_file_contents);
        $new_file_contents = implode(PHP_EOL, $new_file_contents);

        if ($original_file_contents === $new_file_contents) return true; // No changes were made

        // Write the results back to the file
        if (file_put_contents($path, $new_file_contents) === false) {
            $this->logger->warning("Unable to write to `$path`");
            return false;
        }

        return true;
    }
    /**
     * Determines whether a ckey is currently banned from the server.
     *
     * This function is called when a user is verified to determine whether they should be given the banished role or have it taken away.
     * It checks the nomads_bans.txt and tdm_bans.txt files for the ckey.
     *
     * @param string $ckey The ckey to check for banishment.
     * @param bool $bypass (optional) If set to true, the function will not add or remove the banished role from the user.
     * @return bool Returns true if the ckey is found in either ban file, false otherwise.
     */
    public function bancheck(string $ckey, bool $bypass = false, bool $use_cache = false): bool
    {
        return $this->legacy ? $this->legacyBancheck($ckey, $use_cache) : $this->sqlBancheck($ckey);
    }
    public function permabancheck(string $id, bool $bypass = false): bool
    {
        if (! $id = Civ13::sanitizeInput($id)) return false;
        return $this->legacy
            ? $this->legacyPermabancheck($id)
            : $this->sqlPermabancheck($id);
    }
    /**
     * Checks if a player with the given ckey is permabanned based on legacy settings.
     *
     * @param string $ckey The ckey of the player to check.
     * @return bool Returns true if the player is permabanned, false otherwise.
     */
    public function legacyPermabancheck(string $ckey): bool
    {
        if (! @file_exists($path = $this->basedir . Civ13::bans) || ! $file = @fopen($path, 'r')) {
            $this->logger->debug("Unable to open `$path`");
            return false;
        }
        while (($fp = fgets($file, 4096)) !== false) {
            // str_replace(PHP_EOL, '', $fp); // Is this necessary?
            $linesplit = explode(';', trim(str_replace('|||', '', $fp))); // $split_ckey[0] is the ckey
            if ((count($linesplit)>=8) && ($linesplit[8] === $ckey) && ($linesplit[0] === 'Server') && (str_ends_with($linesplit[7], '999 years'))) {
                fclose($file);
                return true;
            }
        }
        fclose($file);
        return false;
    }
    /**
     * Checks if a player with the given ckey is permabanned.
     *
     * @param string $ckey The ckey of the player to check.
     * @return bool Returns true if the player is permabanned, false otherwise.
     */
    public function sqlPermabancheck(string $ckey): bool
    { // TODO, pending /tg/ SQL server implementation
        return false;
    }
    /**
     * Checks if a given ckey is banned based on legacy ban data.
     *
     * @param string $ckey The ckey to check for ban.
     * @return bool Returns true if the ckey is banned, false otherwise.
     */
    public function legacyBancheck(string $ckey, bool $use_cache = false): bool
    {
        if (! $use_cache || ! $this->bancheck_cache) {
            if (! @file_exists($path = $this->basedir . Civ13::bans)) {
                $this->logger->debug("Unable to open `$path`");
                return false;
            }
            if (($file_contents = @file_get_contents($path)) === false) {
                $this->logger->debug("Unable to read `$path`");
                return false;
            }
            $this->bancheck_cache = $file_contents;
        }
        foreach (explode(PHP_EOL, $this->bancheck_cache) as $line)
            if ((count($linesplit = explode(';', trim(str_replace('|||', '', $line)))) >= 8) && ($linesplit[8] === $ckey))
                return true; // $split_ckey[0] is the ckey
        return false;
    }
    /**
     * Checks if a player with the given ckey is banned.
     *
     * @param string $ckey The ckey of the player to check.
     * @return bool Returns true if the player is banned, false otherwise.
     */
    public function sqlBancheck(string $ckey): bool
    { // TODO, pending /tg/ SQL server implementation
        return false;
    }

    /**
     * Updates the ban log in the game server based on the player log.
     *
     * @param int|string|null $ckey The ckey of the player to update the ban log for. If null, all bans will be updated.
     * @param string|null $playerlog The player log content as a string. If not provided, the player log file for this server will be used.
     * @return PromiseInterface<string> The updated ban log as a string, or a throwable string if there was an error.
     */
    public function banlog_update(int|string|null $ckey = null, ?string $playerlog = ''): PromiseInterface
    {
        if (! touch($fp = $this->basedir . Civ13::playerlogs)) {
            $this->logger->warning($err = "Unable to open `$fp`");
            return reject(new FileNotFoundException($err));
        }
        if (! touch($fp = $this->basedir . Civ13::bans)) {
            $this->logger->warning($err = "Unable to open `$fp`");
            return reject(new FileNotFoundException($err));
        }
        if (! $playerlog && ! $playerlog = @file_get_contents($fp = $this->basedir . Civ13::playerlogs)) {
            $this->logger->warning("Unable to read `$fp`");
            return reject(new FileNotFoundException("Unable to read `$fp`"));
        }
        if (! $banlog = @file_get_contents($fp = $this->basedir . Civ13::bans)) {
            $this->logger->warning("Unable to read `$fp`");
            return reject(new FileNotFoundException("Unable to read `$fp`"));
        }
        $this->logger->debug("Updating ban log for {$this->name}. " . ($ckey ? "ckey: $ckey" : "All bans") . '.');
        $temp = [];
        $oldlist = [];
        foreach (explode('|||', $banlog) as $bsplit) {
            if (! $bsplit) continue; // Skip empty lines
            $ban = explode(';', trim($bsplit));
            if (isset($ban[8])) {
                if ($ckey && $ckey != $ban[8]) continue;
                if (isset($ban[9], $ban[10]) && $ban[9] != '0' && $ban[10] != '0') $oldlist[] = $bsplit;
                else $temp[$ban[8]] = $bsplit;
            } else $temp[$ckey] = $bsplit; // This is a ban that doesn't have a ckey, so we'll just add it to the temp array
        }
        /**
         * This function takes a player log's content as a string and updates the corresponding logs in the game server.
         * Each individual player log is a string separated by '|', and each log entry is separated by ';'.
         * The function searches for matching log entries in the game server and updates the corresponding values.
         */
        $logs = explode('|', $playerlog);
        array_map(function ($lsplit) use (&$temp) {
            $log = explode(';', trim($lsplit));
            array_walk_recursive($temp, function (&$arr) use ($log) {
                $a = explode(';', $arr);
                if (isset($a[8]) && $a[8] === $log[0]) {
                    $a[9] = $log[2];
                    $a[10] = $log[1];
                    $arr = implode(';', $a);
                }
            });
        }, $logs);

        $updated = [];
        foreach ($temp as $ban) is_array($ban)
            ? array_merge($updated, $ban)
            : $updated[] = $ban;
        
        /**
         * This function updates the bans list by merging the old list with the updated list.
         * If the updated list is empty, it returns the old list with line breaks replaced by '|||' and appended with a line break.
         * If the updated list is not empty, it merges the old list with the updated list, replaces line breaks with '|||', trims the result, and appends a line break.
         */
        $final = $updated
            ? trim(preg_replace("/(^[\r\n]*|[\r\n]+)[\s\t]*[\r\n]+/", PHP_EOL, implode('|||' . PHP_EOL, array_merge($oldlist, $updated)))) . '|||' . PHP_EOL
            : trim(preg_replace("/(^[\r\n]*|[\r\n]+)[\s\t]*[\r\n]+/", PHP_EOL, implode('|||' . PHP_EOL, $oldlist))) . '|||' . PHP_EOL;
        $ckey ? file_put_contents($fp, $final, FILE_APPEND) : file_put_contents($fp, $final);
        return resolve($final);
    }
    public function listbans(): string|false
    {
        if (! @touch($fp = $this->basedir . Civ13::bans)) {
            $this->logger->warning("Unable to open `$fp`");
            return false;
        }
        if (! $banlog = @file_get_contents($fp)) {
            $this->logger->warning("Unable to read `$fp`");
            return false;
        }
        return $banlog;
    }
    public function merge_banlist(array $banlists): array
    {
        return ($banlist = $this->listbans())
            ? array_merge($banlists, [$this->name => $banlist])
            : $banlists;
    }

    public function panicCheck(string $ckey): void
    {
        if (! $ban_reason = $this->__panicCheck($ckey)) return;
        if (! isset($this->civ13->channel_ids['staff_bot']) || ! $channel = $this->discord->getChannel($this->civ13->channel_ids['staff_bot'])) return;
        $this->civ13->sendMessage($channel, $ban_reason);
    }
    private function __panicCheck(string $ckey): string|false
    {
        if (! $this->panic_bunker) return false;
        if (! isset($this->civ13->verifier)) return false;
        if ($this->civ13->verifier->getVerifiedItem($ckey)) return false; // Whether the ckey is verified
        if (! @file_exists($this->serverdata) || ! $data = @file_get_contents($this->serverdata)) {
            $this->logger->warning("Unable to open `{$this->serverdata}`");
            return false;
        }
        if (self::explodeServerdata($data)[12] ?? true) return false; // Whether restart vote is allowed
        if (! $guild = $this->discord->guilds->get('id', $this->civ13->civ13_guild_id)) return false;
        if (! $admins = $guild->members->filter(fn(Member $member) => $member->roles->has($this->civ13->role_ids['Admin']))) return false; // Get a list of admins from the Discord server
        if (array_reduce($admins->toArray(), function ($carry, $member) { // Check if any of the admins are online
            /** @var bool $carry */
            if ($carry) return $carry;
            /** @var Member $member */
            if (! $item = $this->civ13->verifier->get('discord', $member->id)) return $carry;
            return in_array($item['ss13'], $this->players);
        }, false)) return false;
        return $this->ban(['ckey' => $ckey, 'duration' => '999 years', 'reason' => "Byond account `$ckey` must register and be approved to play. Verify at {$this->civ13->discord_formatted}"]);
    }

    /*
     * These functions determine which of the above methods should be used to process a ban or unban
     * Ban functions will return a string containing the results of the ban
     * Unban functions will return nothing, but may contain error-handling messages that can be passed to $logger->warning()
     */
    public function ban(array $array /* = ['ckey' => '', 'duration' => '', 'reason' => ''] */, ?string $admin = null, bool $permanent = false): string
    {
        if (! isset($array['ckey'])) return "You must specify a ckey to ban.";
        if (! is_numeric($array['ckey']) && ! is_string($array['ckey'])) return "The ckey must be a Byond username or Discord ID.";
        if (! isset($array['duration'])) return "You must specify a duration to ban for.";
        if ($array['duration'] === '999 years') $permanent = true;
        if (! isset($array['reason'])) return "You must specify a reason for the ban.";

        if (is_numeric($array['ckey'] = Civ13::sanitizeInput($array['ckey']))) {
            if (! isset($this->civ13->verifier) || ! $item = $this->civ13->verifier->get('discord', $array['ckey'])) return "Unable to find a ckey for <@{$array['ckey']}>. Please use the ckey instead of the Discord ID.";
            $array['ckey'] = $item['ss13'];
        }
        if (isset($this->civ13->verifier) && $member = $this->civ13->verifier->getVerifiedMember($array['ckey'])) {
            if (! $member->roles->has($this->civ13->role_ids['Banished'])) {
                $string = "Banned for {$array['duration']} with the reason {$array['reason']}";
                $permanent ? $member->setRoles([$this->civ13->role_ids['Banished'], $this->civ13->role_ids['Permabanished']], $string) : $member->addRole($this->civ13->role_ids['Banished'], $string);
            }
        }

        if (! isset($this->timers["ban_cleanup_timer"])) $this->civ13->timers["ban_cleanup_timer"] = $this->civ13->discord->getLoop()->addTimer(300, fn() => $this->cleanupLogs());

        return $this->legacy
            ? $this->legacyBan($array, $admin)
            : $this->sqlBan($array, $admin);
    }
    private function legacyBan(array $array, ?string $admin = null): string
    {
        $admin = $admin ?? $this->discord->username;
        if (str_starts_with(strtolower($array['duration']), 'perm')) $array['duration'] = '999 years';
        if (! @touch($this->discord2ban) || ! $file = @fopen($this->discord2ban, 'a')) {
            $this->logger->warning("Unable to open `{$this->discord2ban}`");
            return "Unable to open `{$this->discord2ban}`" . PHP_EOL;
        }
        fwrite($file, "$admin:::{$array['ckey']}:::{$array['duration']}:::{$array['reason']}" . PHP_EOL);
        fclose($file);
        if (! isset($this->timers["banlog_update_{$array['ckey']}"])) $this->civ13->timers["banlog_update_{$array['ckey']}"] = $this->civ13->discord->getLoop()->addTimer(360, fn() => array_walk($this->civ13->enabled_gameservers, fn(GameServer &$gameserver) => $gameserver->banlog_update($array['ckey'], file_get_contents($this->basedir . Civ13::playerlogs)))); // Attempts to fill in any missing data for the ban
        return "**$admin** banned **{$array['ckey']}** from **{$this->name}** for **{$array['duration']}** with the reason **{$array['reason']}**" . PHP_EOL;
    }
    private function sqlBan(array $array, ?string $admin = null): string
    {
        return "SQL methods are not yet implemented!" . PHP_EOL;
    }

    /**
     * Unbans a player with the specified ckey.
     *
     * @param string $ckey The ckey of the player to unban.
     * @param string|null $admin The name of the admin who is performing the unban. If not provided, the display name of the Discord user will be used.
     * @return void
     */
    public function unban(string $ckey, ?string $admin = null,): void
    {
        $admin ??= $this->discord->username;
        $this->legacy ? $this->legacyUnban($ckey, $admin) : $this->sqlUnban($ckey, $admin);
        if (isset($this->civ13->verifier) && $member = $this->civ13->verifier->getVerifiedMember($ckey)) {
            if ($member->roles->has($this->civ13->role_ids['Banished'])) $member->removeRole($this->civ13->role_ids['Banished'], "Unbanned by $admin");
            if ($member->roles->has($this->civ13->role_ids['Permabanished'])) {
                $member->removeRole($this->civ13->role_ids['Permabanished'], "Unbanned by $admin")->then(function () use (&$member, $admin) {
                    $member->addRole($this->civ13->role_ids['Verified'], "Unbanned by $admin");
                });
            }
        }
    }
    private function legacyUnban(string $ckey, ?string $admin = null): PromiseInterface
    {
        $admin = $admin ?? $this->discord->username;
        if (! @touch($this->discord2unban) || ! $file = @fopen($this->discord2unban, 'a')) {
            $this->logger->warning($err = "Unable to open `$this->discord2unban`");
            return reject(new MissingSystemPermissionException($err));
        }
        fwrite($file, $admin . ":::$ckey");
        fclose($file);
        return resolve(null);
    }
    private function sqlUnban($array, ?string $admin = null): string
    {
        return "SQL methods are not yet implemented!" . PHP_EOL;
    }

    /**
     * Retrieves an array of collections containing information about rounds.
     *
     * @return array An array of collections, where each collection represents a server and its rounds.
     */
    public function getRoundsCollection(): Collection // [string $server, collection $rounds]
    {
        return new Collection(array_filter(array_map(fn($game_id, $round) => array_merge($round, ['game_id' => $game_id]), array_keys($this->rounds), $this->rounds)), 'game_id');
    }
    /**
     * Logs a new round in the game.
     *
     * @param string $game_id The game ID.
     * @param string $time The current time.
     * @return void
     */
    public function logNewRound(string $game_id, string $time): void
    {
        if (isset($this->rounds[$this->current_round])) // If the round already exists and is not the current round
            $this->rounds[$this->current_round]['end'] ??= substr($time, 1, -1) . ' ' . date("m/d/Y"); // Set end time of previous round
        $this->rounds[$this->current_round = $game_id] = [
            'game_id' => $game_id,
            'log' => '/' . date("Y/m-F/d-l") . ".log",
            'start' => substr($time, 1, -1) . ' ' . date("m/d/Y"),
            'end' => null,
            'players' => [],
            'interrupted' => false
        ];
        $this->civ13->VarSave("{$this->key}_rounds.json", $this->rounds);
        $this->civ13->VarSave("{$this->key}_current_round.json", [$this->current_round]);
    }
    /**
     * Logs the login of a player.
     *
     * @param string $ckey The player's ckey.
     * @param string $time The login time.
     * @param string $ip The player's IP address (optional).
     * @param string $cid The player's CID (optional).
     * @return PromiseInterface<?Message> A promise that resolves with the message sent to the staff channel
     */
    public function logPlayerLogin(string $ckey, string $time, string $ip = '', string $cid = ''): PromiseInterface
    {
        if (! $this->enabled) return reject(new \LogicException("Game server is not enabled."));
        if ($ckey === '(NULL)') return reject(new \InvalidArgumentException("Invalid ckey provided."));
        if (! in_array($ckey, $this->players)) $this->players[] = $ckey;
        if (! $this->current_round) {
            $this->logger->warning($err = "No current round found for {$this->key} logPlayerLogin.");
            return reject(new \LogicException($err));
        }
        $this->rounds[$this->current_round]['players'][$ckey] ??= [ // Initialize the player if they don't exist
            'ip' => [],
            'cid' => [],
            'login' => $time
        ];
        if ($ip && ! in_array($ip, $this->rounds[$this->current_round]['players'][$ckey]['ip'] ?? [])) $this->rounds[$this->current_round]['players'][$ckey]['ip'][] = $ip; 
        if ($cid && ! in_array($cid, $this->rounds[$this->current_round]['players'][$ckey]['cid'] ?? [])) $this->rounds[$this->current_round]['players'][$ckey]['cid'][] = $cid;
        $this->civ13->VarSave("{$this->key}_rounds.json", $this->rounds);

        if (! isset($this->civ13->permitted[$ckey])) {
            $ip_data = $this->civ13->getIpData($ip);
            $conditions = [
                'Proxy' => isset($ip_data['proxy']) && $ip_data['proxy'],
                'Hosting' => isset($ip_data['hosting']) && $ip_data['hosting'],
            ];
            $ban_reason = array_reduce(array_keys($conditions), fn($carry, $key) => $carry ?: ($conditions[$key] ? $key : null), null);
            if ($ban_reason && isset($this->civ13->channel_ids['staff_bot']) && $channel = $this->discord->getChannel($this->civ13->channel_ids['staff_bot'])) {
                return $this->civ13->sendMessage($channel, $this->civ13->ban(['ckey' => $ckey, 'duration' => '2 minutes', 'reason' => "You cannot use a VPN or VPS hosting provider to play. Please disable it before reconnecting."], null, null, true) . " ($ban_reason)");
            }
        }
        return resolve(null);
    }
    /**
     * Logs the logout of a player.
     *
     * @param string $ckey The player's ckey.
     * @param string $time The login time.
     * @param string $ip The player's IP address (optional).
     * @param string $cid The player's CID (optional).
     * @return PromiseInterface<array>
     */
    public function logPlayerLogout(string $ckey, string $time): PromiseInterface
    {
        if (! $this->enabled) return reject(new \LogicException("Game server is not enabled."));
        if ($ckey === '(NULL)') return reject(new \InvalidArgumentException("Invalid ckey provided."));
        if (in_array($ckey, $this->players)) unset($this->players[array_search($ckey, $this->players)]);
        if (! $this->current_round) {
            $this->logger->warning($err = "No current round found for {$this->key} logPlayerLogout");
            return reject(new \LogicException($err));
        }
        $this->rounds[$this->current_round]['players'][$ckey] ??= [
            'ip' => [],
            'cid' => [],
            'login' => $time
        ];
        $this->rounds[$this->current_round]['players'][$ckey]['logout'] = $time;
        $this->civ13->VarSave("{$this->key}_rounds.json", $this->rounds);
        return resolve($this->rounds);
    }
    /**
     * Retrieves the rounds based on the provided criteria.
     *
     * @param string|null $ckey The first player's key (optional).
     * @param string|null $ckey2 The second player's key (optional).
     * @param array|null $rounds The array of rounds (optional).
     * @return array The filtered array of rounds.
     */
    public function getRounds(?array $ckeys = [], ?array $rounds = null): array
    {
        if (! $ckeys) return $rounds ?? $this->rounds;        
        return array_filter($rounds ?? $this->rounds, function($round) use ($ckeys) {
            foreach ($ckeys as $ckey) if (! isset($round['players'][$ckey])) return false;
            return true;
        });
    }
    public function getRound(string $game_id): array
    {
        return $this->rounds[$game_id] ?? [];
    }

    /**
     * Retrieves the rank for a given ckey from a file.
     *
     * @param string $ckey The ckey to search for.
     * @return false|string Returns the rank for the ckey as a string if found, or false if the file does not exist or cannot be accessed.
     */
    public function getRank(string $ckey): string
    {
        $line_array = array();
        $return = '';
        if (! @touch($this->ranking_path) || ! $search = @fopen($this->ranking_path, 'r')) {
            $this->logger->warning($return = "Unable to open `{$this->ranking_path}`");
            return $return;
        }
        while (($fp = fgets($search, 4096)) !== false) $line_array[] = $fp;
        fclose($search);
        
        $found = false;
        $result = '';
        foreach ($line_array as $line) {
            $sline = explode(';', trim(str_replace(PHP_EOL, '', $line)));
            if ($sline[1] == $ckey) {
                $found = true;
                $result .= "**{$sline[1]}** has a total rank of **{$sline[0]}**";
            };
        }
        if (! $found) return "No medals found for ckey `$ckey`.";
        return $result;
    }
    /**
     * Retrieves the ranking from a file and returns it as a formatted string.
     *
     * @return PromiseInterface<string> Returns the top 10 ranks as a string if found, or false if the file does not exist or cannot be opened.
     * @throws MissingSystemPermissionException If the file cannot be accessed or read.
     */    
    public function getRanking(): PromiseInterface
    {
        if (! @touch($path = $this->basedir . Civ13::ranking_path) || ! $search = @fopen($path, 'r')) return reject(new MissingSystemPermissionException("Unable to open `$path`"));
        
        $line_array = array();
        while (($fp = fgets($search, 4096)) !== false) $line_array[] = $fp;
        fclose($search);

        $topsum = 0;
        /*$msg = '';
        foreach ($line_array as $line) {
            $sline = explode(';', trim(str_replace(PHP_EOL, '', $line)));
            $msg .= "($topsum): **{$sline[1]}** with **{$sline[0]}** points." . PHP_EOL;
            if (($topsum += 1) > 10) break;
        }*/
        return resolve(implode(PHP_EOL, array_map(function ($line) use (&$topsum) {
            $sline = explode(';', trim(str_replace(PHP_EOL, '', $line)));
            return '('.++$topsum."): **{$sline[1]}** with **{$sline[0]}** points.";
        }, array_slice($line_array, 0, 10)))); // Limit the array to only 10 values
    }
    /**
     * Recalculates the ranking based on the awards data.
     *
     * @return PromiseInterface A promise that resolves when the ranking has been successfully recalculated, or rejects with a MissingSystemPermissionException if there is an error accessing or writing to the necessary files.
     *
     * @throws MissingSystemPermissionException If the awards or ranking files cannot be accessed or written to.
     *
     * The function performs the following steps:
     * 1. Attempts to touch the awards and ranking files to ensure they are accessible.
     * 2. Reads the awards file line by line, skipping empty lines.
     * 3. Parses each line to extract user data and their corresponding medals.
     * 4. Calculates the score for each user based on their medals using predefined medal scores.
     * 5. Sorts the users by their scores in descending order.
     * 6. Writes the sorted ranking to the ranking file.
     */
    public function recalculateRanking(): PromiseInterface
    {
        if ( ! @touch($awards = $this->basedir . Civ13::awards)) return reject(new MissingSystemPermissionException("Unable to access `{$awards}`"));
        if ( ! @touch($ranking_path = $this->basedir . Civ13::ranking_path)) return reject(new MissingSystemPermissionException("Unable to access `{$ranking_path}`"));
        if (! $lines = file($awards, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES)) return reject(new MissingSystemPermissionException("Unable to read `$awards`"));
        $result = array();
        foreach ($lines as $line) {
            $medal_s = 0;
            $duser = explode(';', trim($line));
            $medalScores = [
                'long service medal' => 0.5,
                'wounded badge' => 0.5,
                'tank destroyer silver badge' => 0.75,
                'wounded silver badge' => 0.75,
                'wounded gold badge' => 1,
                'assault badge' => 1.5,
                'tank destroyer gold badge' => 1.5,
                'combat medical badge' => 2,
                'iron cross 1st class' => 3,
                'iron cross 2nd class' => 5,
            ];
            if (! isset($result[$duser[0]])) $result[$duser[0]] = 0;
            if (isset($duser[2]) && isset($medalScores[$duser[2]])) $medal_s += $medalScores[$duser[2]];
            $result[$duser[0]] += $medal_s;
        }
        arsort($result);
        if (file_put_contents($ranking_path, implode(PHP_EOL, array_map(function ($ckey, $score) {
            return "$score;$ckey";
        }, array_keys($result), $result))) === false) return reject(new MissingSystemPermissionException("Unable to write to `$ranking_path`"));
        return resolve(null);
    }
    /**
     * Reads the content of the sports teams file and returns it as a promise.
     *
     * @return PromiseInterface<string> A promise that resolves with the content of the sports teams file.
     * @throws FileNotFoundException If the file does not exist or cannot be read.
     */
    public function sportsteam(): PromiseInterface
    {
        if (! file_exists($fp = $this->civ13->enabled_gameservers['eternal']->basedir . Civ13::sportsteams)) {
            $this->logger->warning($err = "Unable to find `$fp`");
            return reject(new FileNotFoundException($err));
        }
        if (! $content = @file_get_contents($fp)) {
            $this->logger->warning($err = "Unable to read `$fp`");
            return reject(new MissingSystemPermissionException($err));
        }
        return resolve($content);
    }

    /**
     * This function is used to update the contents of files based on the roles of verified members.
     * The callback function is used to determine what to write to the file.
     *
     * @param callable $callback The callback function that determines what to write to the file.
     * @param array $file_paths An array of file paths to update.
     * @param array $required_roles An array of required roles for the members.
     * @return PromiseInterface A promise that resolves when the files are successfully updated, or rejects if there is an error.
     */
    public function updateFilesFromMemberRoles(callable $callback, array $file_paths, array $required_roles): PromiseInterface
    {
        if (! isset($this->civ13->verifier)) {
            $this->logger->error($err = 'Unable to update files from member roles: Verifier is not set.');
            return reject(new VerifierException($err));
        } 
        $file_contents = '';
        foreach ($this->civ13->verifier->verified as $item)
            if ($member = $this->civ13->verifier->getVerifiedMember($item))
                $file_contents .= $callback($member, $item, $required_roles);
        if ($file_contents) foreach ($file_paths as $fp) if (@touch($fp))
            if (file_put_contents($fp, $file_contents) === false) // Attempt to write to the file
                $this->logger->error("Failed to write to file `$fp`"); // Log an error if the write failed
        return resolve(null);
    }
    /**
     * Updates the whitelist based on the member roles.
     *
     * @param array|null $required_roles The required roles for whitelisting. Default is ['Verified'].
     * @return bool Returns true if the whitelist update is successful, false otherwise.
     */
    public function whitelistUpdate(?array $required_roles = ['Verified']): bool
    {
        if (! $this->civ13->hasRequiredConfigRoles($required_roles)) return false;
        if (! $this->enabled) return false;
        if (! @touch($this->whitelist)) {
            $this->logger->warning("Unable to open `{$this->whitelist}`");
            return false;
        }
        $file_paths = [];
        $file_paths[] = $this->whitelist;

        $callback = function (Member $member, array $item, array $required_roles): string
        {
            $string = '';
            foreach ($required_roles as $role)
                if ($member->roles->has($this->civ13->role_ids[$role]))
                    $string .= "{$item['ss13']} = {$item['discord']}" . PHP_EOL;
            return $string;
        };
        $this->updateFilesFromMemberRoles($callback, $file_paths, $required_roles);
        return true;
    }
    /**
     * Updates the faction list based on the required roles.
     *
     * @param array|null $required_roles The required roles for updating the faction list.
     * @return bool Returns true if the faction list is successfully updated, false otherwise.
     */
    public function factionlistUpdate(?array $required_roles = null): bool
    {
        if (! $this->enabled) return false;
        if (! $required_roles) $required_roles = array_merge(Civ13::faction_teams, Civ13::faction_admins);
        if (! $this->civ13->hasRequiredConfigRoles($required_roles)) return false;
        if (! @touch($this->factionlist)) {
            $this->logger->warning("Unable to open `{$this->factionlist}`");
            return false;
        }
        $file_paths = [];
        $file_paths[] = $this->factionlist;

        $callback = function (Member $member, array $item, array $required_roles): string
        {
            return array_reduce($required_roles, function ($carry, $role) use ($member, $item) {
                return $member->roles->has($this->civ13->role_ids[$role])
                    ? $carry . "{$item['ss13']};{$role}" . PHP_EOL
                    : $carry;
            }, '');
        };
        $this->updateFilesFromMemberRoles($callback, $file_paths, $required_roles);
        return true;
    }
    /**
     * Updates admin lists with required roles and permissions.
     *
     * @param array $required_roles An array of required roles and their corresponding permissions.
     * @return PromiseInterface A promise that resolves when the admin list is successfully updated, or rejects if there is an error.
     */
    public function adminlistUpdate(?array $required_roles = null): PromiseInterface
    {
        if (! $this->enabled) return reject(new \LogicException("Game server is not enabled."));
        if (! $required_roles) $required_roles = self::ADMIN_PERMISSIONS;
        if (! $this->civ13->hasRequiredConfigRoles(array_keys($required_roles))) {
            $this->logger->warning($err = "Missing required roles for adminlist update.");
            return reject(new InvalidConfigException($err));
        }
        if (! @touch($this->admins)) {
            $this->logger->warning($err = "Unable to open `{$this->admins}`");
            return reject(new MissingSystemPermissionException($err));
        }
        $file_paths[] = $this->admins;

        $callback = function (Member $member, array $item, array $required_roles): string
        {
            $string = '';
            $checked_ids = [];
            foreach (array_keys($required_roles) as $role) if ($member->roles->has($this->civ13->role_ids[$role])) if (! in_array($member->id, $checked_ids)) {
                $string .= "{$item['ss13']};{$required_roles[$role][0]};{$required_roles[$role][1]}|||" . PHP_EOL;
                $checked_ids[] = $member->id;
            }
            return $string;
        };
        return $this->updateFilesFromMemberRoles($callback, $file_paths, $required_roles);
    }

    public function parseRoundTime(string $time)
    {
        [$hours, $minutes] = array_map('intval', explode(':', $time) + [0, 0]);
        $days = floor($hours / 24);
        $hours = $hours % 24;
        return ($days ? $days . 'd' : '') . ($hours ? $hours . 'h' : '') . $minutes . 'm';
    }
    /**
     * Generates a server status embed.
     *
     * @return Embed The generated server status embed.
     */
    public function generateServerstatusEmbed(): ?Embed
    {
        if ($this->ip !== $this->civ13->httpServiceManager->httpHandler->external_ip) return $this->toEmbed(); // Don't try and access files if the server is not local
        if (! @touch($this->basedir . Civ13::serverdata) || ! $data = @file_get_contents($this->basedir . Civ13::serverdata)) {
            $this->logger->warning("Unable to open `{$this->basedir}" . Civ13::serverdata . "`");
            return null;
        }
        $embed = $this->civ13->createEmbed();
        if (! is_resource($socket = @fsockopen('localhost', intval($this->port), $errno, $errstr, 1))) return $embed->addFieldValues($this->name, 'Offline');
        fclose($socket);
        $data = self::explodeServerdata($data);
        if (isset($data[0])) $embed->addFieldValues($this->name, '<'.$data[0].'>');
        $embed->addFieldValues('Host', $this->host, true);
        if (isset($data[7])) $embed->addFieldValues('Round Time', $this->parseRoundTime($data[7]), true);
        if (isset($data[8])) $embed->addFieldValues('Map', $data[8], true); // Appears twice in the data
        //if (isset($data[3])) $embed->addFieldValues('Gamemode', $data[3], true);
        if (isset($data[9])) $embed->addFieldValues('Epoch', $data[9], true);
        if (isset($data[11])) { // Player list
            $players = explode('&', $data[11]);
            $players = array_filter(array_map(fn($player) => Civ13::sanitizeInput($player), $players));
            if (! $players_list = implode(", ", $players)) $players_list = 'N/A';
            $embed->addFieldValues('Players (' . count($players) . ')', $players_list, true);
        }
        if (isset($data[10])) $embed->addFieldValues('Season', $data[10], true);
        $embed->setFooter($this->civ13->embed_footer);
        //if (isset($data[5])) $embed->addFieldValues('Realtime', $data[5], true);
        //if (isset($data[6])) $embed->addFieldValues('IP', $data[6], true);
        return $embed;
    }
    /**
     * Explodes the server data string into an array by removing specific substrings and splitting by semicolon.
     *
     * The input string is expected to contain the following information in the given format:
     * 0 => Server Status {Online/Offline}
     * 1 => Address byond://{ip_address}
     * 2 => Map: {map}
     * 3 => Gamemode: {gamemode}
     * 4 => Players: {playercount}
     * 5 => realtime={realtime}
     * 6 => world.address={ip}
     * 7 => round_timer={00:00}
     * 8 => map={map}
     * 9 => epoch={epoch}
     * 10 => season={season}
     * 11 => ckey_list={ckey&ckey}
     * 12 => allow_vote_restart={1/0}
     *
     * @param string $data The server data string to be exploded.
     * @return array The exploded server data as an array.
     */
    public static function explodeServerdata(string $data): array
    {
        if (! $data) return [];

        $data = explode(';', str_replace([
            '<Server Status: ',
            '<b>Address</b>: ',
            '<b>Map</b>: ',
            '<b>Gamemode</b>: ',
            '<b>Players</b>: ',
            'round_timer=',
            'map=',
            'epoch=',
            'season=',
            'ckey_list=',
            'allow_vote_restart=',
            '</b>',
            '<b>',
            '>'
        ], '', $data));

        $return = [];
        $return[0] = $return['status'] = $data[0] ?? 'N/A';
        $return[1] = $return['ip'] = $data[1] ?? 'N/A';
        $return[2] = $return['map'] = $data[2] ?? 'N/A';
        $return[3] = $return['gamemode'] = $data[3] ?? 'N/A';
        $return[4] = $return['playercount'] = $data[4] ?? 'N/A';
        $return[5] = $return['realtime'] = $data[5] ?? 'N/A';
        $return[6] = $return['world_address'] = $data[6] ?? 'N/A';
        $return[7] = $return['round_timer'] = $data[7] ?? 'N/A';
        $return[8] = $return['map_name'] = $data[8] ?? 'N/A';
        $return[9] = $return['epoch'] = $data[9] ?? 'N/A';
        $return[10] = $return['season'] = $data[10] ?? 'N/A';
        $return[11] = $return['ckey_list'] = $data[11] ?? 'N/A';
        $return[12] = $return['allow_vote_restart'] = $data[12] ?? 1;
        return $return;
        
    }
    public function toEmbed(): Embed
    {
        return $this->civ13->createEmbed()
            ->setTitle($this->name)
            ->addFieldValues("Server URL", "byond://{$this->ip}:{$this->port}", false)
            ->addFieldValues('Host', $this->host, true)
            ->addFieldValues('Players (' . count($this->players) . ')', empty($this->players) ? 'N/A' : implode(', ', $this->players), true);
    }
    // Magic Methods
    public function __toString(): string
    {
        return $this->key;
    }
    public function __toArray(): array
    {
        $array = get_object_vars($this);
        unset($array['civ13']);
        return $array;
    }
    public function __serialize(): array
    {
        return $this->__toArray();
    }
    public function __debugInfo(): array
    {
        return $this->__toArray();
    }
    public function __destruct()
    {
        foreach ($this->timers as $timer) $this->loop->cancelTimer($timer);
    }
}